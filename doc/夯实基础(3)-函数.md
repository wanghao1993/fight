# 函数

在写这一篇文章的时候，我停止了很长的时间，因为我发现我无法下手，不知道函数应该说些什么？
能想到的就是一等公民，执行上下文，this，高阶函数，函数柯里化仅此而已。

## 1.一等公民

在js中函数是一等公民，在编程语言中，一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量。

```js
// 赋值
const sayHello  = function () {
    console.log('hello')
}

// 传参
function a(func) {
    return func && func()
}

// 返回值
function b() {
    return function () {
        console.log('world')
    }
}

a(sayHello)
```

这个很好理解。

## 2.执行上下文栈

执行上下文栈，遵循 LIFO（后进先出）的规则，通过下面这个栗子来看看看。

```js
// 递归
function recursive(count) {
    if (count === 2) {
        return
    }
    recursive(++count)
}

recursive(0)

```
<img src='http://www.xiaojichao.com/static/upload/20171215/pVd7fNaNvTzy_r_jWCk3.png'>

首先在执行上下文栈 创建一个 全局执行上下文 -> recursive(0) -> recursive(1) -> recursive(2)
当执行完 recursive(2)的时候会退出执行栈，控制流程到达当前栈中的下一个上下文，直到Global context。

了解以后，我们做两个题目。

```js
// 第一段代码
let scope = 'global'
function a() {
    let scope = 'local'

    function f() {
        return scope
    }
    return f()
}
a()

这里的执行上下文栈表示如下

const ecstask = []

1. ecstask.push('global context')
2. ecstask.push('a context')
3. ecstask.push('f context')
4. ecstask.pop('f context')
5. ecstask.pop('a context')

// 第二段代码
let scope = 'global'
function a() {
    let scope = 'local'

    function f() {
        return scope
    }
    return f
}
a()()

const ecstask = []

1. ecstask.push('global context')
2. ecstask.push('a context')
3. ecstask.pop('a context')
4. ecstask.push('f context')
5. ecstask.pop('f context')
```

上面的代码虽然结果一样，但是执行上下文栈是不一样的。

## 3.执行上下文

这个问题在我们日常面试中，应该是时常被问到。
执行上下文（Execution context）一般分为三类： 

1. <b> 全局执行上下文：</b> 全局有切仅有一个全局执行上下文，是默认的，全局执行上下文做了两件事情，第一，创建windows对象，第二，使得this执行windows对象。

2. <b>函数执行上下文：</b> 每个函数执行之前都会创建一个函数执行上下文，该函数内部的代码执行都在这个上下文中

3. <b>eval执行上下文：</b> 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，eval的执行上下文有点诡异.

## 4.执行上下文如何创建

### 4.1 所有执行环境的状态组件
|  组件   | 描述  |
|  ----  | ----  |
| 代码执行状态  | 单元格 |
| 函数  | 单元格 |
| 语法  | 单元格 |
| 函数  | 单元格 |
一个执行上下文包含三个组件：
1.词法环境
2.语法环境
3.this绑定


