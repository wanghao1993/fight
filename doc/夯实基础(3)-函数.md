# 函数

在写这一篇文章的时候，我停止了很长的时间，因为我发现我无法下手，不知道函数应该说些什么？
能想到的就是一等公民，执行上下文，this，高阶函数，函数柯里化仅此而已。

## 1.一等公民

在js中函数是一等公民，在编程语言中，一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量。

```js
// 赋值
const sayHello  = function () {
    console.log('hello')
}

// 传参
function a(func) {
    return func && func()
}

// 返回值
function b() {
    return function () {
        console.log('world')
    }
}

a(sayHello)
```

这个很好理解。

## 2.执行上下文栈

执行上下文栈，遵循 LIFO（后进先出）的规则，通过下面这个栗子来看看看。

```js
// 递归
function recursive(count) {
    if (count === 2) {
        return
    }
    recursive(++count)
}

recursive(0)

```
<img src='http://www.xiaojichao.com/static/upload/20171215/pVd7fNaNvTzy_r_jWCk3.png'>

首先在执行上下文栈 创建一个 全局执行上下文 -> recursive(0) -> recursive(1) -> recursive(2)
当执行完 recursive(2)的时候会退出执行栈，控制流程到达当前栈中的下一个上下文，直到Global context。

了解以后，我们做两个题目。

```js
// 第一段代码
let scope = 'global'
function a() {
    let scope = 'local'

    function f() {
        return scope
    }
    return f()
}
a()

这里的执行上下文栈表示如下

const ecstask = []

1. ecstask.push('global context')
2. ecstask.push('a context')
3. ecstask.push('f context')
4. ecstask.pop('f context')
5. ecstask.pop('a context')

// 第二段代码
let scope = 'global'
function a() {
    let scope = 'local'

    function f() {
        return scope
    }
    return f
}
a()()

const ecstask = []

1. ecstask.push('global context')
2. ecstask.push('a context')
3. ecstask.pop('a context')
4. ecstask.push('f context')
5. ecstask.pop('f context')
```

上面的代码虽然结果一样，但是执行上下文栈是不一样的。

## 3.执行上下文

这个问题在我们日常面试中，应该是时常被问到。
执行上下文（Execution context）一般分为三类： 

1. <b> 全局执行上下文：</b> 全局有切仅有一个全局执行上下文，是默认的，全局执行上下文做了两件事情，第一，创建windows对象，第二，使得this执行windows对象。

2. <b>函数执行上下文：</b> 每个函数执行之前都会创建一个函数执行上下文，该函数内部的代码执行都在这个上下文中

3. <b>eval执行上下文：</b> 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，eval的执行上下文有点诡异.

## 4.执行上下文如何创建

### 4.1 执行上下文中的状态组件
|  组件   | 描述  |
|  ----  | ----  |
| 词法环境  | 指定一个词法环境对象，用于解析该执行环境内的代码创建的标识符引用。 |
| 变量环境	  | 指定一个词法环境对象，其环境数据用于保存由该执行环境内的代码通过 变量表达式 和 函数表达式 创建的绑定。 |
| This绑定  | 指定该执行环境内的 ECMA 脚本代码中 this 关键字所关联的值。 |

this绑定在 [EcamScript2020](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf) 中放到词法环境中了。

### 4.2 词法环境

1.词法环境包含一个环境记录项和一个包含当前词法环境的外层词法环境的引用

大概这样
```js 
function LexicalEnvironment() {
    this.environmentRecord = {}
    this.outerEnvironment = undefined // 可能为null  全局环境的外层没有所以为null
}
```

环境记录项，用于存储需要被声明变量的信息。

### 4.3 环境记录项

环境记录项分为 <font style='color: #b52'>声明式记录项、对象式记录项</font>

#### 4.3.1 声明式记录项

声明式环境记录项用于定义那些将 标识符 与语言值直接绑定的 ECMA 脚本语法元素，例如 函数定义 ， 变量定义 以及 Catch 语句。

#### 4.3.2 对象式环境记录项

用于定义那些将 标识符 与具体对象的属性绑定的 ECMA 脚本元素，例如 程序 以及 With 表达式 。

#### 4.3.3 环境记录项的抽象方法

环境记录项目包含很多的抽象方法

|  方法   | 描述  |
|  ----  | ----  |
| HasBinding(N)  | 判断一个标识符（变量，声明）是否在当前的环境记录项中，N为标识符的字符串 |
| CreateMutableBinding(N, D)  | 在当前环境记录项中，定义一个新的可变绑定标识符，N为标识符的字符串，D为布尔值，表示能否被删除|
| This绑定  | 指定该执行环境内的 ECMA 脚本代码中 this 关键字所关联的值。 |
外层词法环境的引用在作用域链中起到很重要的作用，举个栗子。在你们家族的族谱中，有很多的人。你是第五代子孙，第五代子孙有一本族谱里面记录第五代人的信息，还有一个几代信息的记录，这个几代信息的记录就是外层词法环境的引用，用来告诉别人，想要找这里不存在的人，你得去4代族谱里面去寻找，4代找不到就去3代里面找直到找到，或者直到最顶层。

```txt
全局环境的 outer environment reference 是null

模块的 outer environment reference 是window，包含一个模块顶层this的绑定

```

### 语法环境
